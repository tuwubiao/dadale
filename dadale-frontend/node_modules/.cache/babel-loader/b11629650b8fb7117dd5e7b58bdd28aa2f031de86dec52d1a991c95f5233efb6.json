{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport { watch, isRef, unref, inject, computed, watchEffect, Vue2, defineComponent, shallowRef, toRefs, getCurrentInstance, onMounted, onBeforeUnmount, h, nextTick } from 'vue-demi';\nimport { throttle, init } from 'echarts/core';\nconst METHOD_NAMES = [\"getWidth\", \"getHeight\", \"getDom\", \"getOption\", \"resize\", \"dispatchAction\", \"convertToPixel\", \"convertFromPixel\", \"containPixel\", \"getDataURL\", \"getConnectedDataURL\", \"appendData\", \"clear\", \"isDisposed\", \"dispose\"];\nfunction usePublicAPI(chart) {\n  function makePublicMethod(name) {\n    return (...args) => {\n      if (!chart.value) {\n        throw new Error(\"ECharts is not initialized yet.\");\n      }\n      return chart.value[name].apply(chart.value, args);\n    };\n  }\n  function makePublicMethods() {\n    const methods = /* @__PURE__ */Object.create(null);\n    METHOD_NAMES.forEach(name => {\n      methods[name] = makePublicMethod(name);\n    });\n    return methods;\n  }\n  return makePublicMethods();\n}\nfunction useAutoresize(chart, autoresize, root) {\n  watch([root, chart, autoresize], ([root2, chart2, autoresize2], _, onCleanup) => {\n    let ro = null;\n    if (root2 && chart2 && autoresize2) {\n      const {\n        offsetWidth,\n        offsetHeight\n      } = root2;\n      const autoresizeOptions = autoresize2 === true ? {} : autoresize2;\n      const {\n        throttle: wait = 100,\n        onResize\n      } = autoresizeOptions;\n      let initialResizeTriggered = false;\n      const callback = () => {\n        chart2.resize();\n        onResize?.();\n      };\n      const resizeCallback = wait ? throttle(callback, wait) : callback;\n      ro = new ResizeObserver(() => {\n        if (!initialResizeTriggered) {\n          initialResizeTriggered = true;\n          if (root2.offsetWidth === offsetWidth && root2.offsetHeight === offsetHeight) {\n            return;\n          }\n        }\n        resizeCallback();\n      });\n      ro.observe(root2);\n    }\n    onCleanup(() => {\n      if (ro) {\n        ro.disconnect();\n        ro = null;\n      }\n    });\n  });\n}\nconst autoresizeProps = {\n  autoresize: [Boolean, Object]\n};\nconst onRE = /^on[^a-z]/;\nconst isOn = key => onRE.test(key);\nfunction omitOn(attrs) {\n  const result = {};\n  for (const key in attrs) {\n    if (!isOn(key)) {\n      result[key] = attrs[key];\n    }\n  }\n  return result;\n}\nfunction unwrapInjected(injection, defaultValue) {\n  const value = isRef(injection) ? unref(injection) : injection;\n  if (value && typeof value === \"object\" && \"value\" in value) {\n    return value.value || defaultValue;\n  }\n  return value || defaultValue;\n}\nconst LOADING_OPTIONS_KEY = \"ecLoadingOptions\";\nfunction useLoading(chart, loading, loadingOptions) {\n  const defaultLoadingOptions = inject(LOADING_OPTIONS_KEY, {});\n  const realLoadingOptions = computed(() => ({\n    ...unwrapInjected(defaultLoadingOptions, {}),\n    ...loadingOptions?.value\n  }));\n  watchEffect(() => {\n    const instance = chart.value;\n    if (!instance) {\n      return;\n    }\n    if (loading.value) {\n      instance.showLoading(realLoadingOptions.value);\n    } else {\n      instance.hideLoading();\n    }\n  });\n}\nconst loadingProps = {\n  loading: Boolean,\n  loadingOptions: Object\n};\nlet registered = null;\nconst TAG_NAME = \"x-vue-echarts\";\nfunction register() {\n  if (registered != null) {\n    return registered;\n  }\n  if (typeof HTMLElement === \"undefined\" || typeof customElements === \"undefined\") {\n    return registered = false;\n  }\n  try {\n    const reg = new Function(\"tag\",\n    // Use esbuild repl to keep build process simple\n    // https://esbuild.github.io/try/#dAAwLjIzLjAALS1taW5pZnkAY2xhc3MgRUNoYXJ0c0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7CiAgX19kaXNwb3NlID0gbnVsbDsKCiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7CiAgICBpZiAodGhpcy5fX2Rpc3Bvc2UpIHsKICAgICAgdGhpcy5fX2Rpc3Bvc2UoKTsKICAgICAgdGhpcy5fX2Rpc3Bvc2UgPSBudWxsOwogICAgfQogIH0KfQoKaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWcpID09IG51bGwpIHsKICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnLCBFQ2hhcnRzRWxlbWVudCk7Cn0K\n    \"class EChartsElement extends HTMLElement{__dispose=null;disconnectedCallback(){this.__dispose&&(this.__dispose(),this.__dispose=null)}}customElements.get(tag)==null&&customElements.define(tag,EChartsElement);\");\n    reg(TAG_NAME);\n  } catch (e) {\n    return registered = false;\n  }\n  return registered = true;\n}\ndocument.head.appendChild(document.createElement('style')).textContent = \"x-vue-echarts{display:block;width:100%;height:100%;min-width:0}\\n\";\nconst wcRegistered = register();\nif (Vue2) {\n  Vue2.config.ignoredElements.push(TAG_NAME);\n}\nconst THEME_KEY = \"ecTheme\";\nconst INIT_OPTIONS_KEY = \"ecInitOptions\";\nconst UPDATE_OPTIONS_KEY = \"ecUpdateOptions\";\nconst NATIVE_EVENT_RE = /(^&?~?!?)native:/;\nvar ECharts = defineComponent({\n  name: \"echarts\",\n  props: {\n    option: Object,\n    theme: {\n      type: [Object, String]\n    },\n    initOptions: Object,\n    updateOptions: Object,\n    group: String,\n    manualUpdate: Boolean,\n    ...autoresizeProps,\n    ...loadingProps\n  },\n  emits: {},\n  inheritAttrs: false,\n  setup(props, {\n    attrs\n  }) {\n    const root = shallowRef();\n    const chart = shallowRef();\n    const manualOption = shallowRef();\n    const defaultTheme = inject(THEME_KEY, null);\n    const defaultInitOptions = inject(INIT_OPTIONS_KEY, null);\n    const defaultUpdateOptions = inject(UPDATE_OPTIONS_KEY, null);\n    const {\n      autoresize,\n      manualUpdate,\n      loading,\n      loadingOptions\n    } = toRefs(props);\n    const realOption = computed(() => manualOption.value || props.option || null);\n    const realTheme = computed(() => props.theme || unwrapInjected(defaultTheme, {}));\n    const realInitOptions = computed(() => props.initOptions || unwrapInjected(defaultInitOptions, {}));\n    const realUpdateOptions = computed(() => props.updateOptions || unwrapInjected(defaultUpdateOptions, {}));\n    const nonEventAttrs = computed(() => omitOn(attrs));\n    const nativeListeners = {};\n    const listeners = getCurrentInstance().proxy.$listeners;\n    const realListeners = {};\n    if (!listeners) {\n      Object.keys(attrs).filter(key => isOn(key)).forEach(key => {\n        let event = key.charAt(2).toLowerCase() + key.slice(3);\n        if (event.indexOf(\"native:\") === 0) {\n          const nativeKey = `on${event.charAt(7).toUpperCase()}${event.slice(8)}`;\n          nativeListeners[nativeKey] = attrs[key];\n          return;\n        }\n        if (event.substring(event.length - 4) === \"Once\") {\n          event = `~${event.substring(0, event.length - 4)}`;\n        }\n        realListeners[event] = attrs[key];\n      });\n    } else {\n      Object.keys(listeners).forEach(key => {\n        if (NATIVE_EVENT_RE.test(key)) {\n          nativeListeners[key.replace(NATIVE_EVENT_RE, \"$1\")] = listeners[key];\n        } else {\n          realListeners[key] = listeners[key];\n        }\n      });\n    }\n    function init$1(option) {\n      if (!root.value) {\n        return;\n      }\n      const instance = chart.value = init(root.value, realTheme.value, realInitOptions.value);\n      if (props.group) {\n        instance.group = props.group;\n      }\n      Object.keys(realListeners).forEach(key => {\n        let handler = realListeners[key];\n        if (!handler) {\n          return;\n        }\n        let event = key.toLowerCase();\n        if (event.charAt(0) === \"~\") {\n          event = event.substring(1);\n          handler.__once__ = true;\n        }\n        let target = instance;\n        if (event.indexOf(\"zr:\") === 0) {\n          target = instance.getZr();\n          event = event.substring(3);\n        }\n        if (handler.__once__) {\n          delete handler.__once__;\n          const raw = handler;\n          handler = (...args) => {\n            raw(...args);\n            target.off(event, handler);\n          };\n        }\n        target.on(event, handler);\n      });\n      function resize() {\n        if (instance && !instance.isDisposed()) {\n          instance.resize();\n        }\n      }\n      function commit() {\n        const opt = option || realOption.value;\n        if (opt) {\n          instance.setOption(opt, realUpdateOptions.value);\n        }\n      }\n      if (autoresize.value) {\n        nextTick(() => {\n          resize();\n          commit();\n        });\n      } else {\n        commit();\n      }\n    }\n    function setOption(option, updateOptions) {\n      if (props.manualUpdate) {\n        manualOption.value = option;\n      }\n      if (!chart.value) {\n        init$1(option);\n      } else {\n        chart.value.setOption(option, updateOptions || {});\n      }\n    }\n    function cleanup() {\n      if (chart.value) {\n        chart.value.dispose();\n        chart.value = void 0;\n      }\n    }\n    let unwatchOption = null;\n    watch(manualUpdate, manualUpdate2 => {\n      if (typeof unwatchOption === \"function\") {\n        unwatchOption();\n        unwatchOption = null;\n      }\n      if (!manualUpdate2) {\n        unwatchOption = watch(() => props.option, (option, oldOption) => {\n          if (!option) {\n            return;\n          }\n          if (!chart.value) {\n            init$1();\n          } else {\n            chart.value.setOption(option, {\n              // mutating `option` will lead to `notMerge: false` and\n              // replacing it with new reference will lead to `notMerge: true`\n              notMerge: option !== oldOption,\n              ...realUpdateOptions.value\n            });\n          }\n        }, {\n          deep: true\n        });\n      }\n    }, {\n      immediate: true\n    });\n    watch([realTheme, realInitOptions], () => {\n      cleanup();\n      init$1();\n    }, {\n      deep: true\n    });\n    watchEffect(() => {\n      if (props.group && chart.value) {\n        chart.value.group = props.group;\n      }\n    });\n    const publicApi = usePublicAPI(chart);\n    useLoading(chart, loading, loadingOptions);\n    useAutoresize(chart, autoresize, root);\n    onMounted(() => {\n      init$1();\n    });\n    onBeforeUnmount(() => {\n      if (wcRegistered && root.value) {\n        root.value.__dispose = cleanup;\n      } else {\n        cleanup();\n      }\n    });\n    return {\n      chart,\n      root,\n      setOption,\n      nonEventAttrs,\n      nativeListeners,\n      ...publicApi\n    };\n  },\n  render() {\n    const attrs = Vue2 ? {\n      attrs: this.nonEventAttrs,\n      on: this.nativeListeners\n    } : {\n      ...this.nonEventAttrs,\n      ...this.nativeListeners\n    };\n    attrs.ref = \"root\";\n    attrs.class = attrs.class ? [\"echarts\"].concat(attrs.class) : \"echarts\";\n    return h(TAG_NAME, attrs);\n  }\n});\nexport { INIT_OPTIONS_KEY, LOADING_OPTIONS_KEY, THEME_KEY, UPDATE_OPTIONS_KEY, ECharts as default };","map":{"version":3,"names":["METHOD_NAMES","usePublicAPI","chart","makePublicMethod","name","args","value","Error","apply","makePublicMethods","methods","Object","create","forEach","useAutoresize","autoresize","root","watch","root2","chart2","autoresize2","_","onCleanup","ro","offsetWidth","offsetHeight","autoresizeOptions","throttle","wait","onResize","initialResizeTriggered","callback","resize","resizeCallback","ResizeObserver","observe","disconnect","autoresizeProps","Boolean","onRE","isOn","key","test","omitOn","attrs","result","unwrapInjected","injection","defaultValue","isRef","unref","LOADING_OPTIONS_KEY","useLoading","loading","loadingOptions","defaultLoadingOptions","inject","realLoadingOptions","computed","watchEffect","instance","showLoading","hideLoading","loadingProps","registered","TAG_NAME","register","HTMLElement","customElements","reg","Function","e","wcRegistered","Vue2","config","ignoredElements","push","THEME_KEY","INIT_OPTIONS_KEY","UPDATE_OPTIONS_KEY","NATIVE_EVENT_RE","ECharts","defineComponent","props","option","theme","type","String","initOptions","updateOptions","group","manualUpdate","emits","inheritAttrs","setup","shallowRef","manualOption","defaultTheme","defaultInitOptions","defaultUpdateOptions","toRefs","realOption","realTheme","realInitOptions","realUpdateOptions","nonEventAttrs","nativeListeners","listeners","getCurrentInstance","proxy","$listeners","realListeners","keys","filter","event","charAt","toLowerCase","slice","indexOf","nativeKey","toUpperCase","substring","length","replace","init$1","init","handler","__once__","target","getZr","raw","off","on","isDisposed","commit","opt","setOption","nextTick","cleanup","dispose","unwatchOption","manualUpdate2","oldOption","notMerge","deep","immediate","publicApi","onMounted","onBeforeUnmount","__dispose","render","ref","class","concat","h"],"sources":["../src/composables/api.ts","../src/composables/autoresize.ts","../src/utils.ts","../src/composables/loading.ts","../src/wc.ts","../src/ECharts.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Ref } from \"vue-demi\";\nimport type { EChartsType } from \"../types\";\n\nconst METHOD_NAMES = [\n  \"getWidth\",\n  \"getHeight\",\n  \"getDom\",\n  \"getOption\",\n  \"resize\",\n  \"dispatchAction\",\n  \"convertToPixel\",\n  \"convertFromPixel\",\n  \"containPixel\",\n  \"getDataURL\",\n  \"getConnectedDataURL\",\n  \"appendData\",\n  \"clear\",\n  \"isDisposed\",\n  \"dispose\"\n] as const;\n\ntype MethodName = (typeof METHOD_NAMES)[number];\n\ntype PublicMethods = Pick<EChartsType, MethodName>;\n\nexport function usePublicAPI(\n  chart: Ref<EChartsType | undefined>\n): PublicMethods {\n  function makePublicMethod<T extends MethodName>(\n    name: T\n  ): (...args: Parameters<EChartsType[T]>) => ReturnType<EChartsType[T]> {\n    return (...args) => {\n      if (!chart.value) {\n        throw new Error(\"ECharts is not initialized yet.\");\n      }\n      return (chart.value[name] as any).apply(chart.value, args);\n    };\n  }\n\n  function makePublicMethods(): PublicMethods {\n    const methods = Object.create(null);\n    METHOD_NAMES.forEach(name => {\n      methods[name] = makePublicMethod(name);\n    });\n\n    return methods as PublicMethods;\n  }\n\n  return makePublicMethods();\n}\n","import { watch } from \"vue-demi\";\nimport { throttle } from \"echarts/core\";\n\nimport type { Ref, PropType } from \"vue-demi\";\nimport type { EChartsType, AutoResize } from \"../types\";\n\nexport function useAutoresize(\n  chart: Ref<EChartsType | undefined>,\n  autoresize: Ref<AutoResize | undefined>,\n  root: Ref<HTMLElement | undefined>\n): void {\n  watch(\n    [root, chart, autoresize],\n    ([root, chart, autoresize], _, onCleanup) => {\n      let ro: ResizeObserver | null = null;\n\n      if (root && chart && autoresize) {\n        const { offsetWidth, offsetHeight } = root;\n        const autoresizeOptions = autoresize === true ? {} : autoresize;\n        const { throttle: wait = 100, onResize } = autoresizeOptions;\n\n        let initialResizeTriggered = false;\n\n        const callback = () => {\n          chart.resize();\n          onResize?.();\n        };\n\n        const resizeCallback = wait ? throttle(callback, wait) : callback;\n\n        ro = new ResizeObserver(() => {\n          // We just skip ResizeObserver's initial resize callback if the\n          // size has not changed since the chart is rendered.\n          if (!initialResizeTriggered) {\n            initialResizeTriggered = true;\n            if (\n              root.offsetWidth === offsetWidth &&\n              root.offsetHeight === offsetHeight\n            ) {\n              return;\n            }\n          }\n          resizeCallback();\n        });\n        ro.observe(root);\n      }\n\n      onCleanup(() => {\n        if (ro) {\n          ro.disconnect();\n          ro = null;\n        }\n      });\n    }\n  );\n}\n\nexport const autoresizeProps = {\n  autoresize: [Boolean, Object] as PropType<AutoResize>\n};\n","import { unref, isRef } from \"vue-demi\";\n\nimport type { Injection } from \"./types\";\n\ntype Attrs = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n};\n\n// Copied from\n// https://github.com/vuejs/vue-next/blob/5a7a1b8293822219283d6e267496bec02234b0bc/packages/shared/src/index.ts#L40-L41\nconst onRE = /^on[^a-z]/;\nexport const isOn = (key: string): boolean => onRE.test(key);\n\nexport function omitOn(attrs: Attrs): Attrs {\n  const result: Attrs = {};\n  for (const key in attrs) {\n    if (!isOn(key)) {\n      result[key] = attrs[key];\n    }\n  }\n\n  return result;\n}\n\nexport function unwrapInjected<T, V>(\n  injection: Injection<T>,\n  defaultValue: V\n): T | V {\n  const value = isRef(injection) ? unref(injection) : injection;\n\n  if (value && typeof value === \"object\" && \"value\" in value) {\n    return value.value || defaultValue;\n  }\n\n  return value || defaultValue;\n}\n","import { unwrapInjected } from \"../utils\";\nimport { inject, computed, watchEffect } from \"vue-demi\";\n\nimport type { Ref, InjectionKey, PropType } from \"vue-demi\";\nimport type { EChartsType, LoadingOptions } from \"../types\";\n\nexport const LOADING_OPTIONS_KEY =\n  \"ecLoadingOptions\" as unknown as InjectionKey<\n    LoadingOptions | Ref<LoadingOptions>\n  >;\n\nexport function useLoading(\n  chart: Ref<EChartsType | undefined>,\n  loading: Ref<boolean>,\n  loadingOptions: Ref<LoadingOptions | undefined>\n): void {\n  const defaultLoadingOptions = inject(LOADING_OPTIONS_KEY, {});\n  const realLoadingOptions = computed(() => ({\n    ...unwrapInjected(defaultLoadingOptions, {}),\n    ...loadingOptions?.value\n  }));\n\n  watchEffect(() => {\n    const instance = chart.value;\n    if (!instance) {\n      return;\n    }\n\n    if (loading.value) {\n      instance.showLoading(realLoadingOptions.value);\n    } else {\n      instance.hideLoading();\n    }\n  });\n}\n\nexport const loadingProps = {\n  loading: Boolean,\n  loadingOptions: Object as PropType<LoadingOptions>\n};\n","let registered: boolean | null = null;\n\nexport const TAG_NAME = \"x-vue-echarts\";\n\nexport interface EChartsElement extends HTMLElement {\n  __dispose: (() => void) | null;\n}\n\nexport function register(): boolean {\n  if (registered != null) {\n    return registered;\n  }\n\n  if (\n    typeof HTMLElement === \"undefined\" ||\n    typeof customElements === \"undefined\"\n  ) {\n    return (registered = false);\n  }\n\n  try {\n    // Class definitions cannot be transpiled to ES5\n    // so we are doing a little trick here to ensure\n    // we are using native classes. As we use this as\n    // a progressive enhancement, it will be fine even\n    // if the browser doesn't support native classes.\n    const reg = new Function(\n      \"tag\",\n      // Use esbuild repl to keep build process simple\n      // https://esbuild.github.io/try/#dAAwLjIzLjAALS1taW5pZnkAY2xhc3MgRUNoYXJ0c0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7CiAgX19kaXNwb3NlID0gbnVsbDsKCiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7CiAgICBpZiAodGhpcy5fX2Rpc3Bvc2UpIHsKICAgICAgdGhpcy5fX2Rpc3Bvc2UoKTsKICAgICAgdGhpcy5fX2Rpc3Bvc2UgPSBudWxsOwogICAgfQogIH0KfQoKaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWcpID09IG51bGwpIHsKICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnLCBFQ2hhcnRzRWxlbWVudCk7Cn0K\n      \"class EChartsElement extends HTMLElement{__dispose=null;disconnectedCallback(){this.__dispose&&(this.__dispose(),this.__dispose=null)}}customElements.get(tag)==null&&customElements.define(tag,EChartsElement);\"\n    );\n    reg(TAG_NAME);\n  } catch (e) {\n    return (registered = false);\n  }\n\n  return (registered = true);\n}\n","/* eslint-disable vue/multi-word-component-names */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  defineComponent,\n  shallowRef,\n  toRefs,\n  watch,\n  computed,\n  inject,\n  onMounted,\n  onBeforeUnmount,\n  h,\n  nextTick,\n  watchEffect,\n  getCurrentInstance,\n  Vue2\n} from \"vue-demi\";\nimport { init as initChart } from \"echarts/core\";\n\nimport {\n  usePublicAPI,\n  useAutoresize,\n  autoresizeProps,\n  useLoading,\n  loadingProps\n} from \"./composables\";\nimport { isOn, omitOn, unwrapInjected } from \"./utils\";\nimport { register, TAG_NAME } from \"./wc\";\n\nimport type { PropType, InjectionKey } from \"vue-demi\";\nimport type {\n  EChartsType,\n  EventTarget,\n  Option,\n  Theme,\n  ThemeInjection,\n  InitOptions,\n  InitOptionsInjection,\n  UpdateOptions,\n  UpdateOptionsInjection,\n  Emits\n} from \"./types\";\nimport type { EChartsElement } from \"./wc\";\n\nimport \"./style.css\";\n\nconst __CSP__ = false;\nconst wcRegistered = __CSP__ ? false : register();\n\nif (Vue2) {\n  Vue2.config.ignoredElements.push(TAG_NAME);\n}\n\nexport const THEME_KEY = \"ecTheme\" as unknown as InjectionKey<ThemeInjection>;\nexport const INIT_OPTIONS_KEY =\n  \"ecInitOptions\" as unknown as InjectionKey<InitOptionsInjection>;\nexport const UPDATE_OPTIONS_KEY =\n  \"ecUpdateOptions\" as unknown as InjectionKey<UpdateOptionsInjection>;\nexport { LOADING_OPTIONS_KEY } from \"./composables\";\n\nconst NATIVE_EVENT_RE = /(^&?~?!?)native:/;\n\nexport default defineComponent({\n  name: \"echarts\",\n  props: {\n    option: Object as PropType<Option>,\n    theme: {\n      type: [Object, String] as PropType<Theme>\n    },\n    initOptions: Object as PropType<InitOptions>,\n    updateOptions: Object as PropType<UpdateOptions>,\n    group: String,\n    manualUpdate: Boolean,\n    ...autoresizeProps,\n    ...loadingProps\n  },\n  emits: {} as unknown as Emits,\n  inheritAttrs: false,\n  setup(props, { attrs }) {\n    const root = shallowRef<EChartsElement>();\n    const chart = shallowRef<EChartsType>();\n    const manualOption = shallowRef<Option>();\n    const defaultTheme = inject(THEME_KEY, null);\n    const defaultInitOptions = inject(INIT_OPTIONS_KEY, null);\n    const defaultUpdateOptions = inject(UPDATE_OPTIONS_KEY, null);\n\n    const { autoresize, manualUpdate, loading, loadingOptions } = toRefs(props);\n\n    const realOption = computed(\n      () => manualOption.value || props.option || null\n    );\n    const realTheme = computed(\n      () => props.theme || unwrapInjected(defaultTheme, {})\n    );\n    const realInitOptions = computed(\n      () => props.initOptions || unwrapInjected(defaultInitOptions, {})\n    );\n    const realUpdateOptions = computed(\n      () => props.updateOptions || unwrapInjected(defaultUpdateOptions, {})\n    );\n    const nonEventAttrs = computed(() => omitOn(attrs));\n    const nativeListeners: Record<string, unknown> = {};\n\n    // @ts-expect-error listeners for Vue 2 compatibility\n    const listeners = getCurrentInstance().proxy.$listeners;\n    const realListeners: Record<string, any> = {};\n\n    if (!listeners) {\n      // This is for Vue 3.\n      // We are converting all `on<Event>` props to event listeners compatible with Vue 2\n      // and collect them into `realListeners` so that we can bind them to the chart instance\n      // later in the same way.\n      // For `onNative:<event>` props, we just strip the `Native:` part and collect them into\n      // `nativeListeners` so that we can bind them to the root element directly.\n      Object.keys(attrs)\n        .filter(key => isOn(key))\n        .forEach(key => {\n          // onClick    -> c + lick\n          // onZr:click -> z + r:click\n          let event = key.charAt(2).toLowerCase() + key.slice(3);\n\n          // Collect native DOM events\n          if (event.indexOf(\"native:\") === 0) {\n            // native:click -> onClick\n            const nativeKey = `on${event.charAt(7).toUpperCase()}${event.slice(\n              8\n            )}`;\n\n            nativeListeners[nativeKey] = attrs[key];\n            return;\n          }\n\n          // clickOnce    -> ~click\n          // zr:clickOnce -> ~zr:click\n          if (event.substring(event.length - 4) === \"Once\") {\n            event = `~${event.substring(0, event.length - 4)}`;\n          }\n\n          realListeners[event] = attrs[key];\n        });\n    } else {\n      // This is for Vue 2.\n      // We just need to distinguish normal events and `native:<event>` events and\n      // collect them into `realListeners` and `nativeListeners` respectively.\n      // For `native:<event>` events, we just strip the `native:` part and collect them\n      // into `nativeListeners` so that we can bind them to the root element directly.\n      // native:click   -> click\n      // ~native:click  -> ~click\n      // &~!native:click -> &~!click\n      Object.keys(listeners).forEach(key => {\n        if (NATIVE_EVENT_RE.test(key)) {\n          nativeListeners[key.replace(NATIVE_EVENT_RE, \"$1\")] = listeners[key];\n        } else {\n          realListeners[key] = listeners[key];\n        }\n      });\n    }\n\n    function init(option?: Option) {\n      if (!root.value) {\n        return;\n      }\n\n      const instance = (chart.value = initChart(\n        root.value,\n        realTheme.value,\n        realInitOptions.value\n      ));\n\n      if (props.group) {\n        instance.group = props.group;\n      }\n\n      Object.keys(realListeners).forEach(key => {\n        let handler = realListeners[key];\n\n        if (!handler) {\n          return;\n        }\n\n        let event = key.toLowerCase();\n        if (event.charAt(0) === \"~\") {\n          event = event.substring(1);\n          handler.__once__ = true;\n        }\n\n        let target: EventTarget = instance;\n        if (event.indexOf(\"zr:\") === 0) {\n          target = instance.getZr();\n          event = event.substring(3);\n        }\n\n        if (handler.__once__) {\n          delete handler.__once__;\n\n          const raw = handler;\n\n          handler = (...args: any[]) => {\n            raw(...args);\n            target.off(event, handler);\n          };\n        }\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore EChartsType[\"on\"] is not compatible with ZRenderType[\"on\"]\n        // but it's okay here\n        target.on(event, handler);\n      });\n\n      function resize() {\n        if (instance && !instance.isDisposed()) {\n          instance.resize();\n        }\n      }\n\n      function commit() {\n        const opt = option || realOption.value;\n        if (opt) {\n          instance.setOption(opt, realUpdateOptions.value);\n        }\n      }\n\n      if (autoresize.value) {\n        // Try to make chart fit to container in case container size\n        // is changed synchronously or in already queued microtasks\n        nextTick(() => {\n          resize();\n          commit();\n        });\n      } else {\n        commit();\n      }\n    }\n\n    function setOption(option: Option, updateOptions?: UpdateOptions) {\n      if (props.manualUpdate) {\n        manualOption.value = option;\n      }\n\n      if (!chart.value) {\n        init(option);\n      } else {\n        chart.value.setOption(option, updateOptions || {});\n      }\n    }\n\n    function cleanup() {\n      if (chart.value) {\n        chart.value.dispose();\n        chart.value = undefined;\n      }\n    }\n\n    let unwatchOption: (() => void) | null = null;\n    watch(\n      manualUpdate,\n      manualUpdate => {\n        if (typeof unwatchOption === \"function\") {\n          unwatchOption();\n          unwatchOption = null;\n        }\n\n        if (!manualUpdate) {\n          unwatchOption = watch(\n            () => props.option,\n            (option, oldOption) => {\n              if (!option) {\n                return;\n              }\n              if (!chart.value) {\n                init();\n              } else {\n                chart.value.setOption(option, {\n                  // mutating `option` will lead to `notMerge: false` and\n                  // replacing it with new reference will lead to `notMerge: true`\n                  notMerge: option !== oldOption,\n                  ...realUpdateOptions.value\n                });\n              }\n            },\n            { deep: true }\n          );\n        }\n      },\n      {\n        immediate: true\n      }\n    );\n\n    watch(\n      [realTheme, realInitOptions],\n      () => {\n        cleanup();\n        init();\n      },\n      {\n        deep: true\n      }\n    );\n\n    watchEffect(() => {\n      if (props.group && chart.value) {\n        chart.value.group = props.group;\n      }\n    });\n\n    const publicApi = usePublicAPI(chart);\n\n    useLoading(chart, loading, loadingOptions);\n\n    useAutoresize(chart, autoresize, root);\n\n    onMounted(() => {\n      init();\n    });\n\n    onBeforeUnmount(() => {\n      if (wcRegistered && root.value) {\n        // For registered web component, we can leverage the\n        // `disconnectedCallback` to dispose the chart instance\n        // so that we can delay the cleanup after exsiting leaving\n        // transition.\n        root.value.__dispose = cleanup;\n      } else {\n        cleanup();\n      }\n    });\n\n    return {\n      chart,\n      root,\n      setOption,\n      nonEventAttrs,\n      nativeListeners,\n      ...publicApi\n    };\n  },\n  render() {\n    // Vue 3 and Vue 2 have different vnode props format:\n    // See https://v3-migration.vuejs.org/breaking-changes/render-function-api.html#vnode-props-format\n    const attrs = (\n      Vue2\n        ? { attrs: this.nonEventAttrs, on: this.nativeListeners }\n        : { ...this.nonEventAttrs, ...this.nativeListeners }\n    ) as any;\n    attrs.ref = \"root\";\n    attrs.class = attrs.class ? [\"echarts\"].concat(attrs.class) : \"echarts\";\n    return h(TAG_NAME, attrs);\n  }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}